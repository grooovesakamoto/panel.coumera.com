"use client"

import { useEffect, useState } from 'react'
import { useParams } from 'next/navigation'
import { useDevices, useDevicePhoto } from '@/lib/actcast-client'
import { Badge } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import { ArrowUpDown, Camera, Loader2, PlusCircle, Save, Trash2 } from 'lucide-react'
import Image from 'next/image'
import { ACTCAST_GROUPS } from '@/config/actcast'
import { DetectionLineEditor } from '@/components/detection-line-editor'
import type { DetectionLine } from '@/components/detection-line-editor'
import { toast } from 'sonner'
import { ActcastClient } from '@/lib/actcast-client'
import { 
  Dialog, 
  DialogContent, 
  DialogHeader, 
  DialogTitle,
  DialogFooter,
  DialogTrigger 
} from '@/components/ui/dialog'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { DetectionAreaEditor, DetectionArea } from '@/components/detection-area-editor'

const actcastClient = new ActcastClient(ACTCAST_GROUPS[0])


export default function DeviceDetailPage() {
  const params = useParams()
  const { devices, loading, error } = useDevices()
  const device = devices.find((d) => d.device.id === params.deviceId)
  const { photoUrl, loading: photoLoading, error: photoError, fetchPhoto } = useDevicePhoto(
    ACTCAST_GROUPS[0].groupId.toString(),
    device?.device.id
  )
  const [imageSize, setImageSize] = useState<{ width: number; height: number | null }>({ width: 0, height: null })
  const [detectionLines, setDetectionLines] = useState<DetectionLine[]>([])
  const [detectionAreas, setDetectionAreas] = useState<DetectionArea[]>([])
  
  // 描画モードの状態
  const [isDrawingMode, setIsDrawingMode] = useState(false)
  const [currentPoints, setCurrentPoints] = useState<Point[]>([])
  const [drawingType, setDrawingType] = useState<'line' | 'area' | null>(null)
  
  // 設定変更関連の状態
  const [deviceSettings, setDeviceSettings] = useState<Record<string, any>>({})
  const [isSavingSettings, setIsSavingSettings] = useState(false)
  const [showDebugSettings, setShowDebugSettings] = useState(false)  // デバッグ表示のフラグ
  
  // ネットワーク設定関連の状態
  const [newSsid, setNewSsid] = useState('')
  const [newPassword, setNewPassword] = useState('')
  const [isAddingNetwork, setIsAddingNetwork] = useState(false)
  const [wifiNetworks, setWifiNetworks] = useState<Array<{ssid: string, password?: string}>>([])

  // Act設定情報
  const [currentSettings, setCurrentSettings] = useState<string>('');
  
  // 設定ダイアログ関連
  
  // 初期設定値の読み込み
  useEffect(() => {
    if (device?.device?.act?.device_specific_settings) {
      setDeviceSettings(device.device.act.device_specific_settings)
    }
    
    if (device?.device?.access_points) {
      setWifiNetworks(device.device.access_points)
    }
  }, [device])

  // 画像のプリロード
  useEffect(() => {
    if (photoUrl) {
      const img = document.createElement('img')
      img.onload = () => {
        setImageSize({
          width: img.naturalWidth,
          height: img.naturalHeight
        })
      }
      img.src = photoUrl
    }
  }, [photoUrl])

  // 画像サイズを取得する関数
  const handleImageLoad = (event: React.SyntheticEvent<HTMLImageElement>) => {
    const img = event.target as HTMLImageElement
    setImageSize({
      width: img.naturalWidth,
      height: img.naturalHeight
    })
  }

  // 通行量と入店数の検知ラインを設定から取得
  useEffect(() => {
    if (device?.device?.act?.device_specific_settings && imageSize.width) {
      const actSettings = device.device.act.device_specific_settings;
      const actId = device.device.act.id;
      
      // 検知ラインの設定を読み込む
      if (actId === 9917 && actSettings.detection_lines) {
        try {
          // detection_linesを文字列として処理
          const linesStr = actSettings.detection_lines.toString();
          // ":"で区切られた複数のライン
          const lineStrings = linesStr.split(':');
          
          const lines: DetectionLine[] = lineStrings
            .filter((lineStr: string) => lineStr.trim() !== '')
            .map((lineStr: string, index: number) => {
              // 各ラインはx1,y1,x2,y2の形式
              const coords = lineStr.split(',').map(Number);
              if (coords.length >= 4) {
                // 点を抽出（2点のみの場合）
                let points = [];
                
                // 2点以上の場合、すべての点を取得
                for (let i = 0; i < coords.length; i += 2) {
                  if (i + 1 < coords.length) {
                    points.push({
                      x: coords[i],
                      y: coords[i + 1]
                    });
                  }
                }
                
                return {
                  id: `line-${index}`,
                  name: `LINE${index}`,
                  type: 'traffic',
                  points
                };
              }
              return null;
            })
            .filter((line: DetectionLine | null) => line !== null) as DetectionLine[];
          
          if (lines.length > 0) {
            console.log('Loaded detection lines:', lines);
            setDetectionLines(lines);
          }
        } catch (error) {
          console.error('Error parsing detection lines:', error);
        }
      } else if (actId === 9918 && actSettings.detection_line) {
        try {
          // detection_lineを文字列として処理
          const lineStr = actSettings.detection_line.toString();
          const coords = lineStr.split(',').map(Number);
          
          // 2点以上の場合、すべての点を取得
          let points = [];
          for (let i = 0; i < coords.length; i += 2) {
            if (i + 1 < coords.length) {
              points.push({
                x: coords[i],
                y: coords[i + 1]
              });
            }
          }
          
          if (points.length >= 2) {
            setDetectionLines([{
              id: 'line-0',
              name: 'LINE0',
              type: 'entry',
              points
            }]);
          }
        } catch (error) {
          console.error('Error parsing detection line:', error);
        }
      }
    }
  }, [device?.device?.act?.device_specific_settings, imageSize.width]);

  // 検知ラインの保存処理
  const handleSaveLines = async (lines: DetectionLine[]) => {
    console.log('handleSaveLines called with:', lines);
    setDetectionLines(lines);
    
    if (!device?.device.id || !device?.device.act?.id) {
      toast.error('デバイスまたはActが見つかりません');
      return;
    }
    
    // 既存の設定を取得（ディープコピー）
    const existingSettings = JSON.parse(JSON.stringify(device.device.act.device_specific_settings || {}));
    console.log('Existing settings:', existingSettings);
    
    // 検知ラインのフォーマット
    let settingsToUpdate: any = { ...existingSettings };
    
    if (device.device.act.id === 9917) {
      // 通行量計測の場合は複数のラインをサポート
      // 各ラインの点を文字列形式で保存 "x1,y1,x2,y2:x3,y3,x4,y4"
      const lineStrings = lines.map(line => {
        if (line.points.length < 2) return null;
        
        // 重複する点を取り除く
        const uniquePoints = [];
        for (let i = 0; i < line.points.length; i++) {
          const currentPoint = line.points[i];
          // 次の点が存在し、かつ現在の点と同じ座標の場合はスキップ
          const nextPoint = i < line.points.length - 1 ? line.points[i + 1] : null;
          if (nextPoint && currentPoint.x === nextPoint.x && currentPoint.y === nextPoint.y) {
            continue;
          }
          uniquePoints.push(currentPoint);
        }
        
        // すべての点を使用（3点以上のラインの場合も対応）
        const pointsCoordinates = uniquePoints.flatMap(point => [
          Math.round(point.x),
          Math.round(point.y)
        ]);
        
        // フォーマット: "x1,y1,x2,y2,x3,y3,..."（すべての点）
        return pointsCoordinates.join(',');
      }).filter(line => line !== null);
      
      // 複数ラインを ":" で連結
      settingsToUpdate.detection_lines = lineStrings.join(':');
      
      console.log('Formatted detection lines:', settingsToUpdate.detection_lines);
    } else if (device.device.act.id === 9918) {
      // 入店計測の場合も全ての点を使用
      if (lines.length > 0 && lines[0].points.length >= 2) {
        // 重複する点を取り除く
        const uniquePoints = [];
        for (let i = 0; i < lines[0].points.length; i++) {
          const currentPoint = lines[0].points[i];
          // 次の点が存在し、かつ現在の点と同じ座標の場合はスキップ
          const nextPoint = i < lines[0].points.length - 1 ? lines[0].points[i + 1] : null;
          if (nextPoint && currentPoint.x === nextPoint.x && currentPoint.y === nextPoint.y) {
            continue;
          }
          uniquePoints.push(currentPoint);
        }
        
        // すべての点を使用
        const pointsCoordinates = uniquePoints.flatMap(point => [
          Math.round(point.x),
          Math.round(point.y)
        ]);
        
        // フォーマット: "x1,y1,x2,y2,x3,y3,..."（すべての点）
        settingsToUpdate.detection_line = pointsCoordinates.join(',');
      }
    }
    
    console.log('Settings to update:', settingsToUpdate);
    
    // デバッグ用：送信されるBODYの内容を表示
    const requestBodyJSON = JSON.stringify({ settings: settingsToUpdate }, null, 2);
    toast.info(
      <div>
        <p className="font-bold mb-2">送信データ</p>
        <pre className="bg-gray-100 p-2 overflow-auto max-h-60 text-xs">
          {requestBodyJSON}
        </pre>
      </div>,
      { duration: 10000 }
    );
    
    // 必須の設定値が存在するか確認
    if (device.device.act.id === 9917) {
      // 通行量検知用の必須項目
      if (!settingsToUpdate.hasOwnProperty('aws_access_key_id')) {
        toast.error('設定が不完全です: aws_access_key_id が必要です');
        return;
      }
      if (!settingsToUpdate.hasOwnProperty('aws_secret_access_key')) {
        toast.error('設定が不完全です: aws_secret_access_key が必要です');
        return;
      }
    }
    
    try {
      console.log('Updating settings with wrapped format...');
      setCurrentSettings(JSON.stringify({ settings: settingsToUpdate }, null, 2));
      
      await actcastClient.updateDeviceSettings(
        device.device.id,
        device.device.act.id,
        { settings: settingsToUpdate }
      );
      
      toast.success('設定を保存しました');
    } catch (error) {
      console.error('Error updating settings:', error);
      toast.error('設定の保存に失敗しました');
    }
  }
  
  // デバイス設定の更新
  const updateDeviceSetting = (key: string, value: any) => {
    setDeviceSettings(prev => ({
      ...prev,
      [key]: value
    }));
  }
  
  // 設定の保存
  const handleSaveSettings = async () => {
    if (!device?.device.id || !device?.device.act?.id) {
      toast.error('デバイスまたはActが見つかりません');
      return;
    }
    
    setIsSavingSettings(true);
    
    try {
      // 既存の設定を取得（ディープコピー）
      const existingSettings = JSON.parse(JSON.stringify(device.device.act.device_specific_settings || {}));
      
      // 新しい設定と既存の設定をマージ
      const settingsToUpdate = {
        ...existingSettings,  // 既存の設定を基本として維持
        ...deviceSettings     // 更新された設定を適用
      };
      
      // デバッグ用：送信されるBODYの内容を表示
      const requestBodyJSON = JSON.stringify({ settings: settingsToUpdate }, null, 2);
      toast.info(
        <div>
          <p className="font-bold mb-2">送信データ</p>
          <pre className="bg-gray-100 p-2 overflow-auto max-h-60 text-xs">
            {requestBodyJSON}
          </pre>
        </div>,
        { duration: 10000 }
      );
      
      // 必須の設定値が存在するか確認
      if (device.device.act.id === 9917) {
        // 通行量検知用の必須項目
        if (!settingsToUpdate.hasOwnProperty('aws_access_key_id')) {
          toast.error('設定が不完全です: aws_access_key_id が必要です');
          setIsSavingSettings(false);
          return;
        }
        if (!settingsToUpdate.hasOwnProperty('aws_secret_access_key')) {
          toast.error('設定が不完全です: aws_secret_access_key が必要です');
          setIsSavingSettings(false);
          return;
        }
      }
      
      // 設定を更新
      console.log('Updating settings with wrapped format...');
      
      await actcastClient.updateDeviceSettings(
        device.device.id,
        device.device.act.id,
        { settings: settingsToUpdate }
      );
      
      toast.success('設定を保存しました');
    } catch (error) {
      console.error('Error updating settings:', error);
      toast.error('設定の保存に失敗しました');
    } finally {
      setIsSavingSettings(false);
    }
  }
  
  // Wi-Fi設定の追加
  const handleAddWifiNetwork = () => {
    if (!newSsid.trim()) {
      toast.error('SSIDを入力してください');
      return;
    }
    
    setIsAddingNetwork(true);
    
    // ここでAPIを呼び出してWi-Fi設定を追加
    // 実際のAPIが整備されるまでは、フロントエンドでモックしておく
    setTimeout(() => {
      setWifiNetworks(prev => [
        ...prev,
        { ssid: newSsid, password: newPassword || undefined }
      ]);
      
      setNewSsid('');
      setNewPassword('');
      setIsAddingNetwork(false);
      toast.success('Wi-Fi設定を追加しました');
    }, 500);
  }
  
  // Wi-Fi設定の削除
  const handleRemoveWifiNetwork = (ssid: string) => {
    // ここでAPIを呼び出してWi-Fi設定を削除
    // 実際のAPIが整備されるまでは、フロントエンドでモックしておく
    setWifiNetworks(prev => prev.filter(network => network.ssid !== ssid));
    toast.success(`Wi-Fi設定「${ssid}」を削除しました`);
  }

  // 検知エディタの表示
  const renderDetectionEditor = () => {
    // デバイスまたはActが存在しない場合
    if (!device?.device.act) {
      return (
        <div className="bg-white shadow rounded-lg p-6">
          <p className="text-gray-500">このデバイスにはActがインストールされていません。</p>
        </div>
      );
    }

    const actId = device.device.act.id;

    // 通行量計測の場合
    if (actId === 9917) {
      return (
        <div className="bg-white shadow rounded-lg p-6">
          <h2 className="text-lg font-medium text-gray-900 mb-4">通行量検知ライン設定</h2>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
            <div className="md:col-span-2 relative">
              {photoUrl ? (
                <div 
                  className="relative" 
                  style={{ 
                    userSelect: 'none', 
                    position: 'relative',
                    width: '448px',
                    height: '448px',
                    overflow: 'auto'
                  }}
                >
                  <div 
                    className="relative" 
                    style={{ 
                      userSelect: 'none', 
                      position: 'relative',
                      width: `${imageSize.width}px`,
                      height: imageSize.height ? `${imageSize.height}px` : 'auto',
                      overflow: 'auto'
                    }}
                    onClick={(e) => {
                      if (!isDrawingMode || drawingType !== 'line') return;
                      
                      // クリック位置を取得
                      const imgElement = e.currentTarget.querySelector('img');
                      if (!imgElement) return;
                      
                      const rect = imgElement.getBoundingClientRect();
                      
                      // 実際の画像の表示サイズを取得
                      const displayWidth = imgElement.clientWidth;
                      const displayHeight = imgElement.clientHeight;
                      
                      // クリック位置（ページ上の座標）
                      const clickX = e.clientX - rect.left;
                      const clickY = e.clientY - rect.top;
                      
                      // 画像の実際のサイズ
                      const originalWidth = imageSize.width;
                      const originalHeight = imageSize.height || 1;
                      
                      console.log('Click position:', { 
                        clickX, clickY, 
                        displayWidth, displayHeight,
                        originalWidth, originalHeight,
                        scaledX: clickX, scaledY: clickY 
                      });
                      
                      // 点を追加
                      setCurrentPoints(prev => [...prev, { x: clickX, y: clickY }]);
                    }}
                    onDoubleClick={() => {
                      // 通行量検知は多角線として描画し、ダブルクリックで確定
                      if (!isDrawingMode || drawingType !== 'line' || currentPoints.length < 2) return;
                      
                      handleLineComplete([...currentPoints]);
                      setCurrentPoints([]);
                      setIsDrawingMode(false);
                      toast.success('検知ラインを作成しました');
                    }}
                  >
                    <Image
                      src={photoUrl}
                      alt="Camera View"
                      width={448}
                      height={448}
                      className="w-auto h-auto"
                      unoptimized
                      onLoad={handleImageLoad}
                      style={{ 
                        objectFit: 'contain',
                        width: '448px',
                        height: '448px'
                      }}
                    />
                    {/* SVG overlay for lines */}
                    <svg
                      className="absolute top-0 left-0 w-full h-full pointer-events-none"
                      viewBox="0 0 448 448"
                      preserveAspectRatio="none"
                    >
                      {/* 既存のライン */}
                      {detectionLines.map((line, index) => {
                        if (line.points.length < 2) return null;
                        
                        // 多角線として描画
                        const pointsStr = line.points
                          .map(point => `${point.x},${point.y}`)
                          .join(' ');
                        
                        return (
                          <polyline
                            key={index}
                            points={pointsStr}
                            fill="none"
                            stroke="red"
                            strokeWidth="2"
                            strokeLinejoin="round"
                          />
                        );
                      })}
                      
                      {/* 描画中のライン */}
                      {isDrawingMode && drawingType === 'line' && currentPoints.length > 0 && (
                        <g>
                          {/* 現在の点を結ぶパス */}
                          <polyline
                            points={currentPoints.map(p => `${p.x},${p.y}`).join(' ')}
                            fill="none"
                            stroke="red"
                            strokeWidth="2"
                            strokeDasharray="5,5"
                          />
                          
                          {/* 各点 */}
                          {currentPoints.map((point, idx) => (
                            <circle 
                              key={idx} 
                              cx={point.x} 
                              cy={point.y} 
                              r="4" 
                              fill="red"
                            />
                          ))}
                        </g>
                      )}
                    </svg>
                  </div>
                </div>
              ) : (
                <div className="flex items-center justify-center h-64 bg-gray-100 rounded border">
                  <button 
                    className="flex items-center gap-2 p-3 bg-gray-200 rounded hover:bg-gray-300"
                    onClick={() => fetchPhoto()}
                    disabled={photoLoading}
                  >
                    {photoLoading ? (
                      <Loader2 className="h-5 w-5 animate-spin" />
                    ) : (
                      <Camera className="h-5 w-5" />
                    )}
                    カメラ画像を取得
                  </button>
                </div>
              )}
            </div>
            
            <div className="space-y-4">
              <div className="p-4 bg-gray-50 rounded border">
                <h3 className="font-medium mb-2">検知ライン</h3>
                {detectionLines.length > 0 ? (
                  <ul className="space-y-2">
                    {detectionLines.map((line, index) => (
                      <li key={line.id} className="flex items-center justify-between">
                        <span>{line.name}</span>
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={() => {
                            const newLines = detectionLines.filter(l => l.id !== line.id);
                            setDetectionLines(newLines);
                          }}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </li>
                    ))}
                  </ul>
                ) : (
                  <p className="text-sm text-gray-500">検知ラインはまだ設定されていません</p>
                )}
              </div>
              
              <div className="space-y-3">
                <Button
                  variant="outline"
                  className="w-full"
                  onClick={() => {
                    if (!photoUrl || !imageSize.width || !imageSize.height) {
                      toast.error('まず画像を取得してください');
                      return;
                    }
                    
                    // 描画モードをオン
                    setIsDrawingMode(true);
                    setDrawingType('line');
                    setCurrentPoints([]);
                    toast.info('画像上をクリックして線の頂点を指定してください。ダブルクリックで確定します。');
                  }}
                >
                  <PlusCircle className="mr-2 h-4 w-4" />
                  新規ライン作成
                </Button>
                
                <Button
                  variant="default"
                  className="w-full"
                  onClick={() => handleSaveLines(detectionLines)}
                >
                  <Save className="mr-2 h-4 w-4" />
                  すべて保存
                </Button>
              </div>
            </div>
          </div>
        </div>
      );
    } 
    // 入店計測の場合
    else if (actId === 9918) {
      return (
        <div className="bg-white shadow rounded-lg p-6">
          <h2 className="text-lg font-medium text-gray-900 mb-4">入店検知ライン設定</h2>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
            <div className="md:col-span-2 relative">
              {photoUrl ? (
                <div 
                  className="relative" 
                  style={{ 
                    userSelect: 'none', 
                    position: 'relative',
                    width: '448px',
                    height: '448px',
                    overflow: 'auto'
                  }}
                >
                  <div 
                    className="relative" 
                    style={{ 
                      userSelect: 'none', 
                      position: 'relative',
                      width: `${imageSize.width}px`,
                      height: imageSize.height ? `${imageSize.height}px` : 'auto',
                      overflow: 'auto'
                    }}
                    onClick={(e) => {
                      if (!isDrawingMode || drawingType !== 'line') return;
                      
                      // クリック位置を取得
                      const imgElement = e.currentTarget.querySelector('img');
                      if (!imgElement) return;
                      
                      const rect = imgElement.getBoundingClientRect();
                      
                      // 実際の画像の表示サイズを取得
                      const displayWidth = imgElement.clientWidth;
                      const displayHeight = imgElement.clientHeight;
                      
                      // クリック位置（ページ上の座標）
                      const clickX = e.clientX - rect.left;
                      const clickY = e.clientY - rect.top;
                      
                      // 画像の実際のサイズ
                      const originalWidth = imageSize.width;
                      const originalHeight = imageSize.height || 1;
                      
                      console.log('Click position:', { 
                        clickX, clickY, 
                        displayWidth, displayHeight,
                        originalWidth, originalHeight,
                        scaledX: clickX, scaledY: clickY 
                      });
                      
                      // 点を追加
                      setCurrentPoints(prev => [...prev, { x: clickX, y: clickY }]);
                    }}
                    onDoubleClick={() => {
                      // 入店検知は2点のみ必要
                      if (!isDrawingMode || drawingType !== 'line' || currentPoints.length < 2) return;
                      
                      handleLineComplete([...currentPoints]);
                      setCurrentPoints([]);
                      setIsDrawingMode(false);
                      toast.success('入店検知ラインを作成しました');
                    }}
                  >
                    <Image
                      src={photoUrl}
                      alt="Camera View"
                      width={448}
                      height={448}
                      className="w-auto h-auto"
                      unoptimized
                      onLoad={handleImageLoad}
                      style={{ 
                        objectFit: 'contain',
                        width: '448px',
                        height: '448px'
                      }}
                    />
                    {/* SVG overlay for line */}
                    <svg
                      className="absolute top-0 left-0 w-full h-full pointer-events-none"
                      viewBox="0 0 448 448"
                      preserveAspectRatio="none"
                    >
                      {detectionLines.length > 0 && detectionLines[0].points.length >= 2 && (
                        <line
                          x1={detectionLines[0].points[0].x}
                          y1={detectionLines[0].points[0].y}
                          x2={detectionLines[0].points[detectionLines[0].points.length - 1].x}
                          y2={detectionLines[0].points[detectionLines[0].points.length - 1].y}
                          stroke="red"
                          strokeWidth="2"
                        />
                      )}
                      
                      {/* 描画中のライン */}
                      {isDrawingMode && drawingType === 'line' && currentPoints.length > 0 && (
                        <g>
                          {/* 現在の点を結ぶパス */}
                          <polyline
                            points={currentPoints.map(p => `${p.x},${p.y}`).join(' ')}
                            fill="none"
                            stroke="red"
                            strokeWidth="2"
                            strokeDasharray="5,5"
                          />
                          
                          {/* 各点 */}
                          {currentPoints.map((point, idx) => (
                            <circle 
                              key={idx} 
                              cx={point.x} 
                              cy={point.y} 
                              r="4" 
                              fill="red"
                            />
                          ))}
                        </g>
                      )}
                    </svg>
                  </div>
                </div>
              ) : (
                <div className="flex items-center justify-center h-64 bg-gray-100 rounded border">
                  <button 
                    className="flex items-center gap-2 p-3 bg-gray-200 rounded hover:bg-gray-300"
                    onClick={() => fetchPhoto()}
                    disabled={photoLoading}
                  >
                    {photoLoading ? (
                      <Loader2 className="h-5 w-5 animate-spin" />
                    ) : (
                      <Camera className="h-5 w-5" />
                    )}
                    カメラ画像を取得
                  </button>
                </div>
              )}
            </div>
            
            <div className="space-y-4">
              <div className="p-4 bg-gray-50 rounded border">
                <h3 className="font-medium mb-2">入店検知ライン</h3>
                {detectionLines.length > 0 && detectionLines[0].points.length >= 2 ? (
                  <p>入店ラインが設定されています</p>
                ) : (
                  <p className="text-sm text-gray-500">入店ラインはまだ設定されていません</p>
                )}
              </div>
              
              <div className="space-y-3">
                <Button
                  variant="outline"
                  className="w-full"
                  onClick={() => {
                    if (!photoUrl || !imageSize.width || !imageSize.height) {
                      toast.error('まず画像を取得してください');
                      return;
                    }
                    
                    // 描画モードをオン
                    setIsDrawingMode(true);
                    setDrawingType('line');
                    setCurrentPoints([]);
                    toast.info('画像上をクリックして線の頂点を指定してください。ダブルクリックで確定します。');
                  }}
                >
                  <PlusCircle className="mr-2 h-4 w-4" />
                  ライン作成
                </Button>
                
                <Button
                  variant="default"
                  className="w-full"
                  onClick={() => handleSaveLines(detectionLines)}
                  disabled={detectionLines.length === 0 || detectionLines[0].points.length < 2}
                >
                  <Save className="mr-2 h-4 w-4" />
                  保存
                </Button>
              </div>
            </div>
          </div>
        </div>
      );
    }
    // 滞在計測の場合
    else if (actId === 9916) {
      return (
        <div className="bg-white shadow rounded-lg p-6">
          <h2 className="text-lg font-medium text-gray-900 mb-4">滞在検知エリア設定</h2>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
            <div className="md:col-span-2 relative">
              {photoUrl ? (
                <div 
                  className="relative" 
                  style={{ 
                    userSelect: 'none', 
                    position: 'relative',
                    width: '448px',
                    height: '448px',
                    overflow: 'auto'
                  }}
                >
                  <div 
                    className="relative" 
                    style={{ 
                      userSelect: 'none', 
                      position: 'relative',
                      width: `${imageSize.width}px`,
                      height: imageSize.height ? `${imageSize.height}px` : 'auto',
                      overflow: 'auto'
                    }}
                    onClick={(e) => {
                      if (!isDrawingMode || drawingType !== 'area') return;
                      
                      // クリック位置を取得
                      const imgElement = e.currentTarget.querySelector('img');
                      if (!imgElement) return;
                      
                      const rect = imgElement.getBoundingClientRect();
                      
                      // 実際の画像の表示サイズを取得
                      const displayWidth = imgElement.clientWidth;
                      const displayHeight = imgElement.clientHeight;
                      
                      // クリック位置（ページ上の座標）
                      const clickX = e.clientX - rect.left;
                      const clickY = e.clientY - rect.top;
                      
                      // 画像の実際のサイズ
                      const originalWidth = imageSize.width;
                      const originalHeight = imageSize.height || 1;
                      
                      // 点を追加
                      setCurrentPoints(prev => [...prev, { x: clickX, y: clickY }]);
                      
                      // 最初の点に戻るか、3点以上で多角形として確定可能
                      if (currentPoints.length >= 3) {
                        // 最初の点との距離を計算
                        const firstPoint = currentPoints[0];
                        const distance = Math.sqrt(
                          Math.pow(clickX - firstPoint.x, 2) + 
                          Math.pow(clickY - firstPoint.y, 2)
                        );
                        
                        // 近ければ多角形を閉じる
                        if (distance < 20) {
                          // 多角形を確定
                          const newArea: DetectionArea = {
                            id: `area-${detectionAreas.length}`,
                            name: `エリア ${detectionAreas.length + 1}`,
                            points: [...currentPoints]
                          };
                          setDetectionAreas([...detectionAreas, newArea]);
                          setCurrentPoints([]);
                          setIsDrawingMode(false);
                          toast.success('エリアを作成しました');
                        }
                      }
                    }}
                  >
                    <Image
                      src={photoUrl}
                      alt="Camera View"
                      width={448}
                      height={448}
                      className="w-auto h-auto"
                      unoptimized
                      onLoad={handleImageLoad}
                      style={{ 
                        objectFit: 'contain',
                        width: '448px',
                        height: '448px'
                      }}
                    />
                    {/* SVG overlay for areas */}
                    <svg
                      className="absolute top-0 left-0 w-full h-full pointer-events-none"
                      viewBox="0 0 448 448"
                      preserveAspectRatio="none"
                    >
                      {detectionAreas.map((area, index) => {
                        if (area.points.length < 3) return null;
                        
                        // Create polygon points string
                        const pointsStr = area.points
                          .map(point => `${point.x},${point.y}`)
                          .join(' ');
                        
                        return (
                          <polygon
                            key={index}
                            points={pointsStr}
                            fill="rgba(0, 100, 255, 0.3)"
                            stroke="blue"
                            strokeWidth="2"
                          />
                        );
                      })}
                      
                      {/* 描画中のエリア */}
                      {isDrawingMode && drawingType === 'area' && currentPoints.length > 0 && (
                        <g>
                          {/* 現在の点を結ぶパス */}
                          <polyline
                            points={currentPoints.map(p => `${p.x},${p.y}`).join(' ')}
                            fill="none"
                            stroke="blue"
                            strokeWidth="2"
                            strokeDasharray="5,5"
                          />
                          
                          {/* 各点 */}
                          {currentPoints.map((point, idx) => (
                            <circle 
                              key={idx} 
                              cx={point.x} 
                              cy={point.y} 
                              r="4" 
                              fill="blue"
                            />
                          ))}
                          
                          {/* 最初の点を特別に表示 */}
                          {currentPoints.length > 0 && (
                            <circle 
                              cx={currentPoints[0].x} 
                              cy={currentPoints[0].y} 
                              r="6" 
                              fill="none"
                              stroke="blue"
                              strokeWidth="2"
                            />
                          )}
                        </g>
                      )}
                    </svg>
                  </div>
                </div>
              ) : (
                <div className="flex items-center justify-center h-64 bg-gray-100 rounded border">
                  <button 
                    className="flex items-center gap-2 p-3 bg-gray-200 rounded hover:bg-gray-300"
                    onClick={() => fetchPhoto()}
                    disabled={photoLoading}
                  >
                    {photoLoading ? (
                      <Loader2 className="h-5 w-5 animate-spin" />
                    ) : (
                      <Camera className="h-5 w-5" />
                    )}
                    カメラ画像を取得
                  </button>
                </div>
              )}
            </div>
            
            <div className="space-y-4">
              <div className="p-4 bg-gray-50 rounded border">
                <h3 className="font-medium mb-2">検知エリア</h3>
                {detectionAreas.length > 0 ? (
                  <ul className="space-y-2">
                    {detectionAreas.map((area, index) => (
                      <li key={area.id} className="flex items-center justify-between">
                        <span>{area.name}</span>
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={() => {
                            const newAreas = detectionAreas.filter(a => a.id !== area.id);
                            setDetectionAreas(newAreas);
                          }}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </li>
                    ))}
                  </ul>
                ) : (
                  <p className="text-sm text-gray-500">検知エリアはまだ設定されていません</p>
                )}
              </div>
              
              <div className="space-y-3">
                <Button
                  variant="outline"
                  className="w-full"
                  onClick={() => {
                    if (!photoUrl || !imageSize.width || !imageSize.height) {
                      toast.error('まず画像を取得してください');
                      return;
                    }
                    
                    // 描画モードをオン
                    setIsDrawingMode(true);
                    setDrawingType('area');
                    setCurrentPoints([]);
                    toast.info('画像上をクリックして多角形の頂点を指定してください。最初の点を再度クリックするか、ダブルクリックで確定します。');
                  }}
                >
                  <PlusCircle className="mr-2 h-4 w-4" />
                  新規エリア作成
                </Button>
                
                <Button
                  variant="default"
                  className="w-full"
                  onClick={() => handleSaveAreas(detectionAreas)}
                  disabled={detectionAreas.length === 0}
                >
                  <Save className="mr-2 h-4 w-4" />
                  すべて保存
                </Button>
              </div>
            </div>
          </div>
        </div>
      );
    }
    
    // その他のActの場合
    return (
      <div className="bg-white shadow rounded-lg p-6">
        <p className="text-gray-500">この機能はサポートされていません: {getActName(actId)}</p>
      </div>
    );
  }
  
  // 矩形エリアの完了ハンドラ
  const handleAreaComplete = (area: any) => {
    if (!device?.device.id || !device?.device.act?.id) {
      toast.error('デバイスまたはActが見つかりません');
      return;
    }
    
    console.log('Area completed:', area);
  }
  
  // 滞在検知エリアを設定から取得
  useEffect(() => {
    if (device?.device?.act?.device_specific_settings && imageSize.width && imageSize.height) {
      const actSettings = device.device.act.device_specific_settings;
      const actId = device.device.act.id;
      
      // 滞在計測の場合のみ処理
      if (actId === 9916 && actSettings.area_list) {
        try {
          // area_listが文字列の場合はパースする
          let areaList;
          if (typeof actSettings.area_list === 'string') {
            try {
              // 文字列から配列に変換（JSON形式の場合）
              areaList = JSON.parse(actSettings.area_list.replace(/'/g, '"'));
            } catch (e) {
              // 通常の配列形式の場合
              areaList = JSON.parse(`[${actSettings.area_list}]`);
            }
          } else {
            areaList = actSettings.area_list;
          }

          // エリアリストを検知エリアに変換
          const areas: DetectionArea[] = Array.isArray(areaList) 
            ? areaList.map((coordinates: number[], index: number) => {
                // 4点で構成される多角形の座標を生成
                const points = [];
                for (let i = 0; i < coordinates.length; i += 2) {
                  points.push({
                    x: coordinates[i],
                    y: coordinates[i + 1]
                  });
                }
                
                return {
                  id: `area-${index}`,
                  name: `エリア ${index + 1}`,
                  points
                };
              })
            : [];
          
          console.log('Loaded detection areas:', areas);
          setDetectionAreas(areas);
        } catch (error) {
          console.error('検知エリアの読み込みに失敗しました:', error);
          console.error('Raw area_list:', actSettings.area_list);
          
          // エラーが発生した場合は、直接配列として処理を試みる
          try {
            const rawCoordinates = actSettings.area_list;
            if (Array.isArray(rawCoordinates) && rawCoordinates.length > 0) {
              const areas: DetectionArea[] = [];
              
              // 8個ずつの座標をグループ化
              for (let i = 0; i < rawCoordinates.length; i += 8) {
                const areaCoords = rawCoordinates.slice(i, i + 8);
                if (areaCoords.length === 8) {
                  const points = [];
                  for (let j = 0; j < areaCoords.length; j += 2) {
                    points.push({
                      x: areaCoords[j],
                      y: areaCoords[j + 1]
                    });
                  }
                  
                  areas.push({
                    id: `area-${areas.length}`,
                    name: `エリア ${areas.length + 1}`,
                    points
                  });
                }
              }
              
              console.log('Loaded detection areas (fallback):', areas);
              setDetectionAreas(areas);
            }
          } catch (fallbackError) {
            console.error('Fallback parsing also failed:', fallbackError);
          }
        }
      }
    }
  }, [device?.device?.act?.device_specific_settings, imageSize.width, imageSize.height]);

  // 矩形エリアの保存ハンドラ
  const handleSaveAreas = async (areas: DetectionArea[]) => {
    setDetectionAreas(areas);
    
    if (!device?.device.id || !device?.device.act?.id) {
      toast.error('デバイスまたはActが見つかりません');
      return;
    }
    
    // 既存の設定を取得（ディープコピー）
    const existingSettings = JSON.parse(JSON.stringify(device.device.act.device_specific_settings || {}));
    
    // 検知エリアのフォーマット
    let settingsToUpdate: any = { ...existingSettings };
    
    if (device.device.act.id === 9916) {
      // 滞在検知の場合
      // 各エリアの頂点座標を一次元配列に変換（正規化なし）
      const areaCoordinates = areas.flatMap(area => {
        // 各点を一次元配列に変換 [x1, y1, x2, y2, ...]
        return area.points.flatMap(point => [
          Math.round(point.x),
          Math.round(point.y)
        ]);
      });
      
      settingsToUpdate.area_list = areaCoordinates;
    }
    
    // デバッグ用：送信されるBODYの内容を表示
    const requestBodyJSON = JSON.stringify({ settings: settingsToUpdate }, null, 2);
    toast.info(
      <div>
        <p className="font-bold mb-2">送信データ</p>
        <pre className="bg-gray-100 p-2 overflow-auto max-h-60 text-xs">
          {requestBodyJSON}
        </pre>
      </div>,
      { duration: 10000 }
    );
    
    // 必須の設定値が存在するか確認
    if (device.device.act.id === 9916) {
      // 滞在検知用の必須項目があれば追加
    }
    
    try {
      console.log('Updating settings with wrapped format...');
      setCurrentSettings(JSON.stringify({ settings: settingsToUpdate }, null, 2));
      
      await actcastClient.updateDeviceSettings(
        device.device.id,
        device.device.act.id,
        { settings: settingsToUpdate }
      );
      
      toast.success('設定を保存しました');
    } catch (error) {
      console.error('Error updating settings:', error);
      toast.error('設定の保存に失敗しました');
    }
  }

  // ライン作成完了時の処理
  async function handleLineComplete(points: Point[]) {
    if (!device?.device.id || !device?.device.act?.id) {
      toast.error('デバイスまたはActが見つかりません');
      return;
    }
    
    // アクトIDによって処理を分ける
    if (device.device.act.id === 9917) {
      // 通行量計測の場合
      if (points.length < 2) {
        toast.error('ラインには少なくとも2点が必要です');
        return;
      }
      
      // 新しいラインを作成
      const newLine: DetectionLine = {
        id: `line-${detectionLines.length}`,
        name: `LINE${detectionLines.length}`,
        type: 'traffic',
        points: points
      };
      
      // ラインリストに追加
      const updatedLines = [...detectionLines, newLine];
      setDetectionLines(updatedLines);
      
      // すぐに保存する場合はここでAPIを呼び出す
      // await handleSaveLines(updatedLines);
    } else if (device.device.act.id === 9918) {
      // 入店計測の場合
      if (points.length < 2) {
        toast.error('ラインには少なくとも2点が必要です');
        return;
      }
      
      // 入店計測の場合は単一のラインのみ
      const newLine: DetectionLine = {
        id: 'line-0',
        name: 'LINE0',
        type: 'entry',
        points: points
      };
      
      // 既存のラインを置き換え
      setDetectionLines([newLine]);
      
      // すぐに保存する場合はここでAPIを呼び出す
      // await handleSaveLines([newLine]);
    }
  }

  // ネットワーク情報セクションを改修
  const NetworkInfoSection = () => (
    <div className="bg-white shadow rounded-lg p-6">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-lg font-medium text-gray-900">ネットワーク情報</h2>
        <Dialog>
          <DialogTrigger asChild>
            <Button variant="outline" size="sm" className="text-sm">
              <PlusCircle className="mr-2 h-4 w-4" />
              Wi-Fi追加
            </Button>
          </DialogTrigger>
          <DialogContent className="sm:max-w-[425px]">
            <DialogHeader>
              <DialogTitle>Wi-Fi設定の追加</DialogTitle>
            </DialogHeader>
            <div className="grid gap-4 py-4">
              <div className="grid gap-2">
                <Label htmlFor="ssid">SSID</Label>
                <Input
                  id="ssid"
                  value={newSsid}
                  onChange={(e) => setNewSsid(e.target.value)}
                  placeholder="ネットワーク名"
                />
              </div>
              <div className="grid gap-2">
                <Label htmlFor="password">パスワード</Label>
                <Input
                  id="password"
                  type="password"
                  value={newPassword}
                  onChange={(e) => setNewPassword(e.target.value)}
                  placeholder="パスワード"
                />
              </div>
            </div>
            <DialogFooter>
              <Button 
                type="submit" 
                onClick={handleAddWifiNetwork}
                disabled={isAddingNetwork}
              >
                {isAddingNetwork ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    追加中...
                  </>
                ) : '追加'}
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>
      <dl className="grid grid-cols-1 gap-4 sm:grid-cols-2 mb-4">
        <div>
          <dt className="text-sm font-medium text-gray-500">接続中のSSID</dt>
          <dd className="mt-1 text-sm text-gray-900">{device?.status?.connected_ssid || '-'}</dd>
        </div>
        <div>
          <dt className="text-sm font-medium text-gray-500">電波強度</dt>
          <dd className="mt-1 text-sm text-gray-900">
            {device?.status?.signal_strength ? `${device.status.signal_strength} dBm` : '-'}
          </dd>
        </div>
      </dl>
      
      <h3 className="text-sm font-medium text-gray-900 mb-2">登録済みWi-Fi設定</h3>
      <div className="space-y-2 max-h-48 overflow-y-auto">
        {wifiNetworks.length > 0 ? (
          wifiNetworks.map((network, index) => (
            <div 
              key={index} 
              className="flex items-center justify-between bg-gray-50 p-2 rounded"
            >
              <div className="text-sm">
                <div className="font-medium">{network.ssid}</div>
                {network.password && (
                  <div className="text-xs text-gray-500">パスワード: ********</div>
                )}
              </div>
              <Button
                variant="ghost"
                size="sm"
                onClick={() => handleRemoveWifiNetwork(network.ssid)}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </div>
          ))
        ) : (
          <div className="text-sm text-gray-500 py-2">
            登録済みのWi-Fi設定はありません
          </div>
        )}
      </div>
    </div>
  )

  
  // 直接送信フォーマットを選択
  
  // ラップ送信フォーマットを選択
  
  // ダイアログをキャンセル
  const handleCancelFormatDialog = () => {
    console.log('Dialog cancelled');
    
    // ダイアログを閉じる
    setIsFormatDialogOpen(false);
    
    // ダイアログのPromiseを拒否
    if (window.rejectSettingsDialog) {
      window.rejectSettingsDialog(new Error('Dialog cancelled'));
      delete window.resolveSettingsDialog;
      delete window.rejectSettingsDialog;
    }
  };

  if (loading) {
    return (
      <div className="container py-4 flex justify-center items-center min-h-[600px]">
        <Loader2 className="h-8 w-8 animate-spin text-gray-400" />
      </div>
    )
  }

  if (error || !device) {
    return (
      <div className="container py-4">
        <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">
          デバイス情報の取得に失敗しました。
        </div>
      </div>
    )
  }

  const getStatusBadge = () => {
    if (!device.status?.foundness) return <Badge className="text-base px-4 py-1" variant="secondary">不明</Badge>
    
    switch (device.status.foundness) {
      case 'Found':
        return <Badge className="text-base px-4 py-1 bg-green-500 hover:bg-green-600">オンライン</Badge>
      case 'Lost':
        return <Badge className="text-base px-4 py-1 bg-red-500 hover:bg-red-600">オフライン</Badge>
      default:
        return <Badge className="text-base px-4 py-1" variant="secondary">{device.status.foundness}</Badge>
    }
  }

  const formatBytes = (bytes: number) => {
    const units = ['B', 'KB', 'MB', 'GB']
    let size = bytes
    let unitIndex = 0
    while (size >= 1024 && unitIndex < units.length - 1) {
      size /= 1024
      unitIndex++
    }
    return `${size.toFixed(1)} ${units[unitIndex]}`
  }

  const formatUptime = (seconds: number) => {
    const days = Math.floor(seconds / 86400)
    const hours = Math.floor((seconds % 86400) / 3600)
    const minutes = Math.floor((seconds % 3600) / 60)
    return `${days}日 ${hours}時間 ${minutes}分`
  }

  // 設定値の表示用フォーマット
  const formatSettingValue = (value: any): string => {
    if (value === undefined || value === null) return '-'
    if (typeof value === 'boolean') return value ? 'はい' : 'いいえ'
    if (typeof value === 'number') return value.toString()
    if (typeof value === 'string') return value
    return JSON.stringify(value)
  }

  // 設定値の比較
  const compareSettings = (base: any, specific: any): 'same' | 'different' => {
    if (typeof base !== typeof specific) return 'different'
    if (typeof base === 'object') {
      return JSON.stringify(base) === JSON.stringify(specific) ? 'same' : 'different'
    }
    return base === specific ? 'same' : 'different'
  }

  // 設定項目の表示名マッピング
  const getSettingLabels = (actId?: number): Record<string, string> => {
    if (!actId) return {}

    switch (actId) {
      case 9917: // 通行量計測
        return {
          display: 'ディスプレイ出力',
          model: '検出方法',
          rotation: '画像回転',
          detection_lines: '検知ライン',
        }
      case 9918: // 入店計測
        return {
          display: 'ディスプレイ出力',
          camera_rotation: '画像回転',
          use_usb_camera: 'USBカメラ使用',
          detection_line: '検知ライン',
        }
      case 9916: // 滞在計測
        return {
          display: 'ディスプレイ出力',
          model: '検出方法',
          rotation: '画像回転',
          use_usb_camera: 'USBカメラ使用',
          area_list: '検知エリア',
        }
      case 9960: // 視認計測
        return {
          display: 'ディスプレイ出力',
          rotation: '画像回転',
          use_usb_camera: 'USBカメラ使用',
          maximum_pitch: '最大ピッチ角',
          minimum_pitch: '最小ピッチ角',
          maximum_yaw: '最大ヨー角',
          minimum_yaw: '最小ヨー角',
          maximum_roll: '最大ロール角',
          minimum_roll: '最小ロール角',
        }
      default:
        return {}
    }
  }

  // ソフトウェア名のマッピング
  const getActName = (actId?: number): string => {
    if (!actId) return '-'

    switch (actId) {
      case 9917:
        return '通行量'
      case 9918:
        return '入店数'
      case 9916:
        return '滞在数'
      case 9960:
        return '視認数'
      default:
        return '-'
    }
  }

  interface Point {
    x: number
    y: number
  }

  return (
    <div className="container py-4">
      <div className="flex items-center space-x-4 mb-4">
        <h1 className="text-2xl font-bold">
          {device.device.name}
        </h1>
        {getStatusBadge()}
      </div>

      <div className="mb-4">
        <Button 
          variant="outline" 
          onClick={() => setShowDebugSettings(!showDebugSettings)}
        >
          {showDebugSettings ? 'デバッグ情報を隠す' : 'デバッグ情報を表示'}
        </Button>
      </div>

      {showDebugSettings && device.device.act?.device_specific_settings && (
        <div className="mb-6 p-4 bg-gray-100 rounded-md overflow-auto max-h-96">
          <h3 className="text-md font-semibold mb-2">デバイス設定 (デバッグ用)</h3>
          <pre className="text-xs">
            {JSON.stringify(device.device.act.device_specific_settings, null, 2)}
          </pre>
        </div>
      )}

      <div className="grid gap-6">
        {/* 基本情報 */}
        <div className="bg-white shadow rounded-lg p-6">
          <h2 className="text-lg font-medium text-gray-900 mb-4">基本情報</h2>
          <dl className="grid grid-cols-1 gap-4 sm:grid-cols-2">
            <div>
              <dt className="text-sm font-medium text-gray-500">デバイスID</dt>
              <dd className="mt-1 text-sm text-gray-900">{device.device.id}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-gray-500">MACアドレス</dt>
              <dd className="mt-1 text-sm text-gray-900">{device.device.mac_addr}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-gray-500">ハードウェアID</dt>
              <dd className="mt-1 text-sm text-gray-900">{device.device.hardware_id}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-gray-500">登録日時</dt>
              <dd className="mt-1 text-sm text-gray-900">
                {new Date(device.device.registered_at).toLocaleString('ja-JP')}
              </dd>
            </div>
          </dl>
        </div>

        {/* システム情報 */}
        <div className="bg-white shadow rounded-lg p-6">
          <h2 className="text-lg font-medium text-gray-900 mb-4">システム情報</h2>
          <dl className="grid grid-cols-1 gap-4 sm:grid-cols-2">
            <div>
              <dt className="text-sm font-medium text-gray-500">ファームウェアバージョン</dt>
              <dd className="mt-1 text-sm text-gray-900">{device.device.firmware_version}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-gray-500">最終OS起動日時</dt>
              <dd className="mt-1 text-sm text-gray-900">
                {new Date(device.device.last_os_booted_at).toLocaleString('ja-JP')}
              </dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-gray-500">稼働時間</dt>
              <dd className="mt-1 text-sm text-gray-900">{device.status?.uptime ? formatUptime(device.status.uptime) : '-'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-gray-500">CPU温度</dt>
              <dd className="mt-1 text-sm text-gray-900">
                {device.status?.cpu_temperature ? `${device.status.cpu_temperature.toFixed(1)}°C` : '-'}
              </dd>
            </div>
          </dl>
        </div>

        {/* リソース情報 */}
        <div className="bg-white shadow rounded-lg p-6">
          <h2 className="text-lg font-medium text-gray-900 mb-4">リソース情報</h2>
          <dl className="grid grid-cols-1 gap-4 sm:grid-cols-2">
            <div>
              <dt className="text-sm font-medium text-gray-500">メモリ使用量</dt>
              <dd className="mt-1 text-sm text-gray-900">
                {device.status?.memory && device.status?.memory_usage
                  ? `${formatBytes(device.status.memory_usage)} / ${formatBytes(device.status.memory)}`
                  : '-'}
              </dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-gray-500">ディスク使用量</dt>
              <dd className="mt-1 text-sm text-gray-900">
                {device.status?.disk && device.status?.disk_usage
                  ? `${formatBytes(device.status.disk_usage)} / ${formatBytes(device.status.disk)}`
                  : '-'}
              </dd>
            </div>
          </dl>
        </div>

        {/* ネットワーク情報 */}
        <NetworkInfoSection />

        {/* Act設定情報 */}
        <div className="bg-white shadow rounded-lg p-6">
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center gap-4">
              <h2 className="text-lg font-medium text-gray-900">Act設定情報</h2>
              <div className="text-sm text-gray-500">
                <span className="font-medium">ソフトウェア:</span> {getActName(device.device.act?.id)}
              </div>
            </div>
            <div>
              <Button 
                variant="default" 
                size="sm" 
                className="text-sm"
                onClick={() => handleSaveSettings()}
                disabled={isSavingSettings}
              >
                {isSavingSettings ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    保存中...
                  </>
                ) : (
                  <>
                    <Save className="mr-2 h-4 w-4" />
                    設定を保存
                  </>
                )}
            </Button>
            </div>
          </div>
          <div className="overflow-hidden">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {device.device.act && Object.entries(getSettingLabels(device.device.act?.id)).map(([key, label]) => {
                // 検知ライン座標と検知エリア座標の表示を削除
                if (key === 'detection_lines' || key === 'detection_line' || key === 'area_list') {
                  return null;
                }
                
                const value = device.device.act?.device_specific_settings[key];

                  return (
                  <div key={key} className="space-y-2">
                    <Label htmlFor={key}>{label}</Label>
                    {key === 'model' ? (
                      <Select
                        defaultValue={value || "head"}
                        onValueChange={(val) => updateDeviceSetting(key, val)}
                      >
                        <SelectTrigger id={key} className="w-full">
                          <SelectValue placeholder="選択してください" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="head">head</SelectItem>
                          <SelectItem value="body">body</SelectItem>
                        </SelectContent>
                      </Select>
                    ) : key === 'rotation' ? (
                      <Select
                        defaultValue={value?.toString() || "0"}
                        onValueChange={(val) => updateDeviceSetting(key, Number(val))}
                      >
                        <SelectTrigger id={key} className="w-full">
                          <SelectValue placeholder="選択してください" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="0">0度</SelectItem>
                          <SelectItem value="180">180度</SelectItem>
                        </SelectContent>
                      </Select>
                    ) : typeof value === 'boolean' ? (
                      <Select
                        defaultValue={value ? "true" : "false"}
                        onValueChange={(val) => updateDeviceSetting(key, val === "true")}
                      >
                        <SelectTrigger id={key} className="w-full">
                          <SelectValue placeholder="選択してください" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="true">有効</SelectItem>
                          <SelectItem value="false">無効</SelectItem>
                        </SelectContent>
                      </Select>
                    ) : typeof value === 'number' ? (
                      <Input
                        id={key}
                        type="number"
                        defaultValue={value}
                        onChange={(e) => updateDeviceSetting(key, Number(e.target.value))}
                      />
                    ) : (
                      <Input
                        id={key}
                        defaultValue={value as string}
                        onChange={(e) => updateDeviceSetting(key, e.target.value)}
                      />
                    )}
                  </div>
                );
              })}
            </div>
          </div>
        </div>

        {/* デバイス写真 */}
        <div className="bg-white shadow rounded-lg p-6">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-lg font-medium text-gray-900">デバイス写真</h2>
            <Button 
              variant="outline" 
              size="sm" 
              className="text-sm"
              onClick={() => fetchPhoto()}
              disabled={photoLoading}
            >
              {photoLoading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  更新中...
                </>
              ) : (
                <>
                  <Camera className="mr-2 h-4 w-4" />
                  写真を更新
                </>
              )}
            </Button>
          </div>
          <div className="relative w-full overflow-auto rounded-lg bg-gray-100" style={{ maxHeight: '80vh' }}>
            {photoLoading ? (
              <div className="h-96 flex flex-col items-center justify-center bg-gray-100 rounded">
                <Loader2 className="h-12 w-12 animate-spin text-gray-400 mb-4" />
                <p className="text-gray-500 font-medium">写真を読み込んでいます...</p>
                <p className="text-gray-400 text-sm mt-1">しばらくお待ちください</p>
              </div>
            ) : photoUrl ? (
              renderDetectionEditor()
            ) : photoError ? (
              <div className="h-96 flex items-center justify-center bg-gray-100 rounded">
                <div className="text-center">
                  <div className="text-red-500 mb-2">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-12 w-12 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                    </svg>
                  </div>
                  <p className="text-gray-700">{photoError}</p>
                </div>
              </div>
            ) : (
              <div className="h-96 flex flex-col items-center justify-center bg-gray-100 rounded">
                <Camera className="h-12 w-12 text-gray-400 mb-4" />
                <p className="text-gray-500">写真を取得するには更新ボタンをクリックしてください</p>
              </div>
            )}
          </div>
        </div>
      </div>
      
    </div>
  )
} 